'use client';

import React, { useState, useMemo } from 'react';
import StatusBadge from './statusbadge';
import ResendButton from './resendbutton';
import { WalletInvitesTableProps } from './types';
import AddInviteModal from './AddInviteModal';
import DatePicker from 'react-datepicker';
import 'react-datepicker/dist/react-datepicker.css';


type SortDirection = 'asc' | 'desc';
type SortableColumn = keyof WalletInvitesTableProps['data'][0];
type GroupByOption = 'trial' | 'country' | 'language' | null;

const WalletInvitesTable: React.FC<WalletInvitesTableProps> = ({ data = [], onResend }) => {
  const [search, setSearch] = useState('');
  const [sortColumn, setSortColumn] = useState<SortableColumn | null>(null);
  const [sortDirection, setSortDirection] = useState<SortDirection>('asc');
  const [groupBy, setGroupBy] = useState<GroupByOption>(null);
  const [filters, setFilters] = useState<{ [key: string]: string }>({});
  const [showAddModal, setShowAddModal] = useState(false);
  const [expandedGroups, setExpandedGroups] = useState<Record<string, boolean>>({});
  const [startDate, setStartDate] = useState<Date | null>(null);
  const [endDate, setEndDate] = useState<Date | null>(null);

  const parseDate = (dateStr: string): Date | null => {
    if (!dateStr) return null;
    const [day, month, year] = dateStr.split('/').map(Number);
    if (!day || !month || !year) return null;
    return new Date(year, month - 1, day);
  };

  const handleSort = (column: SortableColumn) => {
    if (sortColumn === column) {
      setSortDirection((prev) => (prev === 'asc' ? 'desc' : 'asc'));
    } else {
      setSortColumn(column);
      setSortDirection('asc');
    }
  };

  const handleFilterChange = (key: string, value: string) => {
    setFilters((prev) => ({ ...prev, [key]: value }));
  };

  const clearFilters = () => {
    setFilters({});
    setGroupBy(null);
    setSearch('');
    setStartDate(null);
    setEndDate(null);
  };

  const handleSearchChange = (value: string) => {
    setSearch(value);
  };

  const filteredData = useMemo(() => {
    return data
      .filter((row) => {
        const searchLower = search.toLowerCase();
        const matchesSearch =
          row.trial.toLowerCase().includes(searchLower) ||
          row.language.toLowerCase().includes(searchLower) ||
          row.mobile.includes(search) ||
          row.country.toLowerCase().includes(searchLower) ||
          row.cardId.toLowerCase().includes(searchLower);

        const matchesFilters = Object.entries(filters).every(([key, val]) => {
          if (!val) return true;
          return (row as any)[key]?.toString().toLowerCase() === val.toLowerCase();
        });

        let matchesDate = true;
        if (startDate || endDate) {
          const rowDate = parseDate(row.sentDate);
          if (rowDate) {
            if (startDate && rowDate < startDate) matchesDate = false;
            if (endDate && rowDate > endDate) matchesDate = false;
          } else {
            matchesDate = false;
          }
        }

        return matchesSearch && matchesFilters && matchesDate;
      })
      .sort((a, b) => {
        if (!sortColumn) return 0;

        const valA = a[sortColumn];
        const valB = b[sortColumn];

        if (valA == null) return 1;
        if (valB == null) return -1;

        if (sortColumn === 'sentDate') {
          const dateA = parseDate(valA as string)?.getTime() ?? 0;
          const dateB = parseDate(valB as string)?.getTime() ?? 0;
          return sortDirection === 'asc' ? dateA - dateB : dateB - dateA;
        }

        if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
        if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
        return 0;
      });
  }, [data, search, filters, sortColumn, sortDirection, startDate, endDate]);

  const groupedData = useMemo(() => {
    if (!groupBy) return null;
    return filteredData.reduce((groups: { [key: string]: typeof filteredData }, row) => {
      const key = (row as any)[groupBy] || 'Other';
      if (!groups[key]) groups[key] = [];
      groups[key].push(row);
      return groups;
    }, {});
  }, [filteredData, groupBy]);

  const toggleGroup = (group: string) => {
    setExpandedGroups((prev) => ({ ...prev, [group]: !prev[group] }));
  };

  const renderSortIcon = (column: SortableColumn) => {
    if (sortColumn !== column) return '‚¨ç';
    return sortDirection === 'asc' ? '‚ñ≤' : '‚ñº';
  };

  const renderTableHeader = () => (
    <thead className="bg-gray-50 border-b border-gray-300 sticky top-0 z-10">
      <tr>       
        {[
          { label: 'Clinical trial', key: 'Clinical trial' },
          { label: 'Language', key: 'language' },
          { label: 'Country/Region', key: 'country' },
          { label: 'Mobile', key: 'mobile' },        
          { label: 'Card ID', key: 'cardId' },
          { label: 'Request ID', key: 'requestId' },
          { label: 'Sent date', key: 'sentDate' },
          { label: 'Status', key: 'status' },
        ].map(({ label, key }) => (
          <th
            key={key}
            className="px-3 py-2 cursor-pointer font-semibold text-left"
            onClick={() => handleSort(key as SortableColumn)}
          >
            {label} {renderSortIcon(key as SortableColumn)}
          </th>
        ))}
        <th className="px-3 py-2 w-20"></th>
      </tr>
    </thead>
  );

  const renderTableRows = (rows: typeof filteredData) =>
    rows.length === 0 ? (
      <tr>
        <td colSpan={11} className="text-center py-6 text-gray-500">
          No invites found.
        </td>
      </tr>
    ) : (
      rows.map((row) => (
        <tr key={row.id} className="border-b hover:bg-gray-50">
         
          <td className="px-3 py-2">{row.trial}</td>
          <td className="px-3 py-2">{row.language}</td>
            <td className="px-3 py-2">{row.country}</td>
          <td className="px-3 py-2">{row.mobile}</td>        
          <td className="px-3 py-2">{row.cardId}</td>
          <td className="px-3 py-2">{row.requestId}</td>
          <td className="px-3 py-2">
            {row.sentDate
              ? new Date(row.sentDate).toLocaleString('en-GB', {
                  day: '2-digit',
                  month: '2-digit',
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                })
              : '-'}
          </td>
          <td className="px-3 py-2">
            <StatusBadge status={row.status} />
          </td>
          <td className="px-3 py-2">
            <ResendButton status={row.status} onResend={() => onResend(row.id)} />
          </td>
        </tr>
      ))
    );

  return (
    <div className="max-w-screen-xl mx-auto p-6 w-100 bg-white rounded-2xl shadow-lg mt-11  ">
      {/* Header */}
      <div className="flex flex-col sm:flex-row justify-between items-center mb-4 gap-3">
        <h2 className="text-2xl font-semibold">Wallet Invites</h2>
        <div className="flex items-center space-x-3 w-full sm:w-auto">
          <div className="relative w-full sm:w-56">
            <input
              type="search"
              placeholder="Search"
              value={search}
              onChange={(e) => handleSearchChange(e.target.value)}
              className="w-full px-4 py-1 h-18 border rounded-full text-sm"
            />
            <span className="absolute right-3 top-1.5 text-sm">üîç</span>
          </div>
        <button
  className="bg-[#007fb2] text-white px-3 py-1 rounded-full text-sm flex items-center space-x-1"
  onClick={() => setShowAddModal(true)}
>
  <span className="text-base">Ôºã</span>
  <span>Add</span>
</button>
        </div>
      </div>

      {/* Filters */}
      <div className="flex flex-wrap items-center gap-x-6 gap-y-4  mb-4 text-xs">
        <div className="flex items-center gap-x-2 gap-y-2 space-x-1">
          <span className="font-semibold">GROUP</span>
          <select
            value={groupBy || ''}
            onChange={(e) => setGroupBy(e.target.value as GroupByOption)}
            className="px-2 py-1 w-24 h-8  bg-gray-100  rounded-md border"
          >
            <option value="">Select</option>
            <option value="trial">Trial</option>
            <option value="country">Country</option>
            <option value="language">Language</option>
          </select>
        </div>

        <div className="flex flex-wrap items-center gap-3">
          <span className="font-semibold">FILTER</span>
          {['trial', 'country', 'language', 'status'].map((key) => (
            <select
              key={key}
              value={filters[key] || ''}
              onChange={(e) => handleFilterChange(key, e.target.value)}
              className="px-2 py-1 w-30  h-8 bg-gray-100 rounded-md border gap-4"
            >
              <option value="">
                {key === 'trial'
                  ? 'Clinical Trial'
                  : key === 'country'
                  ? 'Country/Region'
                  : key.charAt(0).toUpperCase() + key.slice(1)}
              </option>
              {[...new Set(data.map((row) => (row as any)[key]).filter(Boolean))].map((val) => (
                <option key={val} value={val}>
                  {val}
                </option>
              ))}
            </select>
          ))}
        </div>

        <div className="flex items-center space-x-2">
          <span className="font-bold">DATE</span>
          <div className="flex items-center h-8 w-44 border rounded-md">
            <DatePicker
              selected={startDate}
              onChange={(date: Date) => setStartDate(date)}
              placeholderText="Start"
              className="w-20 px-1  text-xs"
              dateFormat="dd/MM/yyyy"
               wrapperClassName="date-picker-high-z-index"
            />
            <div className="h-full w-px bg-gray-300" />
            <DatePicker
              selected={endDate}
              onChange={(date: Date) => setEndDate(date)}
              placeholderText="End"
              className="w-20 px-1 text-xs"
              dateFormat="dd/MM/yyyy"
               wrapperClassName="date-picker-high-z-index"
            />
          </div>
        </div>

        {(Object.keys(filters).length > 0 || groupBy || search || startDate || endDate) && (
          <button onClick={clearFilters} className="ml-2 px-3 py-1 rounded-full border text-xs">
            ‚úï
          </button>
        )}
      </div>

      {/* Table (Flat or Grouped) */}
      {!groupBy ? (
        <div className="mb-4 border rounded-lg overflow-hidden shadow-sm max-w-[1200px] mx-auto ">
          <div className="overflow-x-auto">
            <div className="max-h-[300px] overflow-y-auto table-container overflow-y-auto">
              <table className="w-full text-sm border-collapse">
                {renderTableHeader()}
                <tbody>{renderTableRows(filteredData)}</tbody>
              </table>
            </div>
          </div>
        </div>
      ) : (
        Object.entries(groupedData ?? {}).map(([group, rows]) => (
          <div key={group} className="mb-4 border rounded-lg overflow-hidden shadow-sm">
            <button
              onClick={() => toggleGroup(group)}
              className="w-full flex justify-between items-center bg-gray-100 px-3 py-2 text-left font-medium text-sm"
            >
              <span>
                {groupBy.charAt(0).toUpperCase() + groupBy.slice(1)}: {group} ({rows.length})
              </span>
              <span>{expandedGroups[group] ? '‚àí' : '+'}</span>
            </button>
            {expandedGroups[group] && (
              <div className="overflow-x-auto">
                <div className="max-h-[600px] overflow-y-auto">
                  <table className="w-full text-sm border-collapse">
                    {renderTableHeader()}
                    <tbody>{renderTableRows(rows)}</tbody>
                  </table>
                </div>
              </div>
            )}
          </div>
        ))
      )}

      <AddInviteModal isOpen={showAddModal} onClose={() => setShowAddModal(false)} />
    </div>
  );
};

export default WalletInvitesTable;
